class Animal

{

public:

virtual void speak()

{

cout << "动物在说话"  << endl;

}

};

class Cat :public Animal

{

public:

void speak()

{

cout << "小猫在说话" << endl;

}

};

//调用dospeak , speak函数的地址早已指定 静态联编 ，编译阶段就确定好了地址

//如果想调用cat的speak ，不能提前绑定好了函数的地址了， 所以需要在运行时再去确定函数的地址

//动态联编写法 dospeak改为虚函数 ，在父类上声明虚函数 发生了动态

//什么是多态 ：父类的引用或者指针 指向 子类对象

void dospeak(Animal & animal)

{

animal.speak();

}

//如果发生了继承关系  编译器允许进行类型转换

void test1()

{

Cat cat;

dospeak(cat);

}
