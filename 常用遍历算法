

#include <vector>

#include <algorithm>

#include <functional>

using namespace std;

void myprint(int s)

{

    cout << s << endl;

}

class myprint1

{

    public:

    void operator()(int s)

    {

        cout << s << endl;

    }

};

void test1()

{

    vector<int> s;



    for(int i = 0; i < 10; i++)

    {

        s.push_back(i);

    }

    for_each(s.begin(), s.end(),myprint1());

}

class myprint2

{

    public:

    void operator()(int s)

    {

        cout << s << endl;

        m_count++;

    }

    int m_count;

};

//for_each有返回值

void test2()

{

    vector<int> s;



    for(int i = 0; i < 10; i++)

    {

        s.push_back(i);

    }

    myprint2 p2 = for_each(s.begin(), s.end(),myprint2());

    cout << "次数： " << p2.m_count << endl;

}

struct myprint3 :public binary_function<int, int, void>

{

    void operator()(int s, int num) const

    {

        cout << s + num << endl;

    }

};

//for_each可以绑定参数输出

void test3()

{

    vector<int> s;



    for(int i = 0; i < 10; i++)

    {

        s.push_back(i);

    }

    for_each(s.begin(), s.end(), bind2nd(myprint3(), 100));

}

class transformtest

{

    public:

    int operator()(int val)

    {

        return val + 10;

    }

};

void test4()

{

    vector<int> h;

    for(int i = 0; i < 10; i++)

    {

        h.push_back(i);

    }

    vector<int> htarget; //目标容器

    htarget.resize(h.size());

    transform(h.begin(), h.end(), htarget.begin(), transformtest());

    for_each(htarget.begin(), htarget.end(), [](int val){cout << val << endl; });

}

//transform 第二种用法 //将两个容器相加搬运到目标容器

class transformtest2

{

    public:

    int operator()(int val, int val2)

    {

        return val + val2;

    }

};

void test5()

{

    vector<int> w;

    vector<int> w2;

    for(int i = 0; i < 10; i++)

    {

        w.push_back(20 + i);

        w2.push_back(50 + i);

    }

    vector<int> wtarget; //目标容器

    wtarget.resize(w.size());

    transform(w.begin(), w.end(), w2.begin(), wtarget.begin(), transformtest2());

    for_each(wtarget.begin(), wtarget.end(), [](int val){cout << val << endl; });

}
