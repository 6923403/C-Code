
#include <set>



void printset(set<int> & f2)

{

    for(set<int>::iterator it = f2.begin(); it != f2.end(); it++)

    {

        cout << *it << " ";

    }

    cout << endl;

}

void test1()

{

    set<int> f;

    //关联式容器 key进行排序 从小到大排序

    f.insert(1);

    f.insert(7);

    f.insert(3);

    f.insert(4);

    f.insert(5);

    printset(f);

    if(f.empty())

    {

        cout << "空 " ;

    }

    else

    cout << "size :" << f.size() << endl;

    f.erase(f.begin()); //删除头元素

    f.erase(5); //删除 元素5

    printset(f);

}

void test2()

{

    set<int> f;

    //关联式容器 key进行排序 从小到大排序

    f.insert(1);

    f.insert(7);

    f.insert(3);

    f.insert(3);

    f.insert(5);

    f.insert(2);

    f.insert(2);

    //对于set 没有value key就是value

    set<int>::iterator pos = f.find(7);

    if(pos != f.end())

    {

        cout << *pos << endl;

    }

    else

    {

        cout << "未找到" << endl;

    }

    //cout(key) //查找key个数 set的结果只有0 、1

    int num = f.count(5);

    cout << "5的个数 " << num << endl; //返回1

    //lower_bound(keylem) //返回第一个key >= keylem元素的迭代器

    //upper_bound(keylem) //返回第一个key > keylem元素的迭代器

    set<int>::iterator it2 = f.lower_bound(6); //条件2 == 元素2 返回2 ； 条件6 返回 6或者比6大的 本次返回7

    cout << *it2 << endl;



    set<int>::iterator it3 = f.upper_bound(2); //只返回i比条件2大的。

    cout << *it3 << endl;

    //key与keylem相等的上下限两个迭代器

    //上下限是lower_bound 、upper_bound

    pair<set<int>::iterator, set<int>::iterator> ret = f.equal_range(3);

    cout << *(ret.first) << endl; //lower_bound里的值

    cout << *(ret.second) << endl; //upper_bound里的值 

}
